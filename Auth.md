# Auth

## 0. Запуск

Требуется научиться запускать приложение и убедиться, что все хорошо.

Приложение использует https, поэтому для корректной работы понадобится сертификат.
.NET Core умеет создавать сертификаты для localhost. Только надо установить такой сертификат в доверенные.
Для этого запусти команду:
```bash
dotnet dev-certs https --trust
```

Запусти приложение под отладкой. Должен запусться браузер и открыть стартовую страницу приложения.
Убедись, что при запуске в папке `PhotosApp` автоматически создался файл `PhotosApp.db` с базой данных Sqlite.

Открой файл `PhotosApp.db` с помощью сервиса https://sqliteonline.com/.
Убедись, что в нем есть таблица `Photos`, выведи записи из нее.


## 1. Identity

### 1.1. Scaffolding

Требуется сгенерировать код `Identity`, а затем ее корректно подключить к приложению.

*Scaffolding (англ. строительные леса) — генерация кода по заданной разработчиком спецификации.*

Прежде всего потребуется установить новый инструмент для .NET Core CLI — генератор кода:
```bash
dotnet tool install -g dotnet-aspnet-codegenerator
```

Кроме того, в проект надо добавить NuGet-пакеты для кодогенерации.
Выполни в папке с проектом PhotosApp:
```bash
dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design
dotnet add package Microsoft.EntityFrameworkCore.Design
```

Наконец, можно выполнить команду генерации кода `Identity` (также в папке с проектом PhotosApp):
```bash
dotnet aspnet-codegenerator identity -dc UsersDbContext -u PhotoAppUser -sqlite
```

Дополнительные параметры команды указывают:

- имя `DbContext`, который будет использоваться для хранения информации о пользователях,
- класс пользователя, хранимого в базе данных,
- что, в качестве базы данных надо использовать Sqlite, а не SQL Server.


В проекте `PhotosApp` в папке `Areas/Identity` был сгенерирован требующийся код.

`Area` в ASP.NET Core MVC — это в каком-то смысле подприложение с собственной адресацией.
В случае `Identity` все адреса страниц будут иметь префикс `/Indentity`, после которого будет обычный путь до страницы.

Посмотри структуру папки  `Areas/Identity`.
Обрати внимание на файл `Areas/Identity/IdentityHostingStartup.cs`.
Код из него будет автоматически запускаться после `Startup.cs` и завершать конфигурирование.
Также обрати внимание, что страницы сгенерированы по технологии `Razor Pages`.
В отличие от MVC, где «разметка» (View) и «обработка» (Controller) находится в разных местах,
здесь все находится в двух соседних файлах. Например, для страницы `Identity/Pages/Account/Login.cshtml`,
разметка находится в `Login.cshtml`, а обработка в `Login.cshtml.cs`.


Чтобы `Razor Pages` заработали, надо их добавить в контейнер, а также подключить в качестве обработчиков запросов.

Код для `ConfigureServices`:
```cs
var mvc = services.AddControllersWithViews();
services.AddRazorPages();
if (env.IsDevelopment())
    mvc.AddRazorRuntimeCompilation();
```
*Замечение. Раз `AddRazorRuntimeCompilation` в подключается контексте `AddControllersWithViews`,*
*то для `AddRazorPages` можно снова не подключать.*
*Компиляция представлений на лету без перестроения всего проекта будет работать и для razor pages.*

Код для `Configure`:
```cs
app.UseEndpoints(endpoints =>
{
    endpoints.MapControllerRoute("default", "{controller=Photo}/{action=Index}/{id?}");
    endpoints.MapRazorPages();
});
```


Также в `Views/Shared` был сгенерирован `_LoginPartial.cshtml`, содержищий разметку для отображения
ссылок для регистрации/входа/выхода пользователя в меню приложения.

Ссылки регистрации/входа/выхода надо добавить в меню приложения.
Для этого открой `Views/Shared/_Layout.cshtml` и добавь вставку `_LoginPartial.cshtml` с помощью tag-хелпера
сразу после других ссылок:
```cshtml
<ul class="navbar-nav mr-auto">
    ...
</ul>
<partial name="_LoginPartial"/>
```

Можешь убедиться, что ссылки появились и при переходе по ним открываются страницы `Identity`.

Только ничего не работает, потому что пользователей нет, да и таблица базы данных для них еще не создана.


### 1.2. Миграции

Для манипулирования базой данных нужно установить инструмент Entity Framework Core для .NET CLI:
```bash
dotnet tool install --global dotnet-ef
```

В коде появился новый контекст. Чтобы обновить БД для хранения данных из него, надо создать миграцию:
```bash
dotnet ef migrations add Users --context UsersDbContext
```
Миграция — это план обновления. Его можно применять к БД, которыми будет пользоваться приложение.

Чтобы миграция успешно создалась:

1. Приложение должно компилироваться без ошибок,
2. При старте приложения не должно быть ошибок,
т.е. код конфигурирования (в `Startup.cs` и `IdentityHostingStartup.cs`) должен работать корректно
3. Приложение не должно быть запущенным.
Все это нужно, чтобы команда миграции смогла построить и запустить проект,
а затем получить через рефлексию всю необходимую информацию о контексте.

Если при запуске миграции встретилась такая замысловатая ошибка про «design time», проверь предыдущие три пункта.
`Unable to create an object of type 'UsersDbContext'. For the different patterns supported at design time, see https://go.microsoft.com/fwlink/?linkid=851728`


После создания миграции ее надо запустить на имеющейся базе данных Sqlite.
Сделай это с помощью следующей команды:
```bash
dotnet ef database update --context UsersDbContext
```
Теперь база данных обновлена и в ней можно хранить информацию о пользователях.
Посмотри с помощью https://sqliteonline.com/ какие таблицы были созданы. Заметь, что их достаточно много.


Для целей разработки можно вместо `dotnet ef database update` использовать такой вызов метода:
```cs
dbContext.Database.Migrate()
```
Здесь `dbContext` — экземпляр класса-наследника `DbContext`.

Посмотри как этот метод используется в файле `Data/DataExtensions.cs` для `PhotosDbContext`,
и напиши аналогичный код для `UsersDbContext`.
В результате, если файл `PhotosApp.db` удален, то при запуске приложения
он автоматически восстановится со всеми таблицами.


Теперь надо добавить тестовых пользователей.
Это умеет делат метод `SeedWithSampleUsersAsync` из `Data/DataExtensions.cs`.
Вызови его в `PrepareDB`, чтобы при старте приложения создавались тестовые пользователи.
Подсказка: `UserManager<PhotoAppUser>` можно достать из `ServiceProvider`.


### 1.3. Аутентификация

Чтобы под пользователем можно было зайти, подключи middleware аутентификации `UseAuthentication`
 и middleware авторизации `UseAuthorization` в `Startup.cs`.
Их вызов обязательно должен быть после подключения middleware для определения обработчика запроса (`UseRouting`),
но перед подключением middleware для выполнения запроса (`UseEndpoints`).
Это позволит слою `UseAuthorization` проверить пользователя на соответствие требованиям обработчика,
который стал известен после `UseRouting`, и отменить выполнение обработки в `UseEndpoints`,
если у пользователя не хватает прав. Слой `UseAuthentication` также пользуется информацией из `UseRouting`.
Должно получиться так:
```cs
app.UseRouting();

app.UseAuthentication();
app.UseAuthorization();

app.UseEndpoints(endpoints => ...);
```


Теперь попробуй зайти под пользователем `cristina`. Пароль можно найти в `Data/DataExtensions.cs`.


Но даже если зайти под нужным пользователем, его фотки не будут показываться, пока не поправить `PhotoController`.
Измени метод `GetOwnerId` так, чтобы он возвращал идентификатор залогиненного пользователя, а не идентификатор `vicky`:
```cs
private string GetOwnerId()
{
    return User.FindFirstValue(ClaimTypes.NameIdentifier);
}
```


Снова зайди под `cristina`, а затем под `vicky`. Фотографии должны быть разными.


Осталась пара нюансов.

1. При заходе на страницы управления аккаунтом (кликни на имя пользователя в меню приложения, чтобы туда попасть)
показывается неправильная шапка страницы.
Чтобы починить в файле `/Areas/Identity/Pages/Account/Manage/_Layout.cshtml` поменяй `Layout`.
Корректное значение для приложения — `"/Views/Shared/_Layout.cshtml"`

2. Logout работает некорректно. После него не происходит перехода на главную страницу приложения,
а в верхнем меню остается имя пользователя. Это происходит потому, что в `_LoginPartial.cshtml`
указан некорректный `asp-route-returnUrl`. Должен быть `@Url.Action("Index", "Photo", new { area = "" })`.


### 1.4. Авторизация

Теперь надо сделать, чтобы анонимный пользователь автоматически пересылался на страницу входа
при выполнении любых действий с фотографиями. Доступной должна остаться только главная страница.

Для этого достаточно пометить атрибутом `[Authorize]` все методы или контроллеры, которые требуется защитить.
Если пометить атрибутом `[Authorize]` контроллер, но надо разрешить некоторый метод, то метод помечается
атрибутом `[AllowAnonymous]`.

Защити все действия над фотографиями из `PhotoController`, кроме `Index`.


## 1.5. Требования к паролям

Настройки по умолчанию для паролей хороши:

- есть требования на длину и используемые символы,
- пароли не хранятся о открытом виде, а хэшируются с солью.

Но такие настройки не всегда подходят.

В большинстве случаев достаточно конфигурирования. Начни с этого.

Настройки по умолчанию для паролей можно посмотреть тут:
https://docs.microsoft.com/ru-ru/aspnet/core/security/authentication/identity-configuration#password

Заодно в том же документе можно посмотреть настройки по умолчанию для входа:
https://docs.microsoft.com/ru-ru/aspnet/core/security/authentication/identity-configuration#sign-in

Чтобы облегчить себе жизнь во время прохождения блока:

1. Скопируй явную конфигурацию из документации в `IdentityHostingStartup.cs`
2. Выстави настройки для паролей `RequireDigit`, `RequireNonAlphanumeric`,
и `RequireUppercase` в `false`. Оставь `RequireLowercase` в `true`!
3. Также выстави в настройках входа `RequireConfirmedAccount` в `false`.
Убедись, что нигде в `IdentityHostingStartup.cs` больше `RequireConfirmedAccount` в `true` не выставляется.

В реальных проектах так делать не надо, это только для разработки и обучения :)

При желании можешь поменять пароли для `vicky`, `cristina` и `dev` в файле `DataExtensions.cs`, чтобы было проще.
Зарегистрируй нового пользователя с простым паролем из 6 символов: у тебя должно получиться.
Затем выйди из него и зайди снова. Вход должен получиться, несмотря на то, что ты не подтверждал email.

Все же может потребоваться добавить новые правила проверки паролей.
Например, проверить, что новый пароль не совпадает с логином пользователя.
Проверка уже реализована в `Services/UsernameAsPasswordValidator.cs`. Изучи ее код.
А затем добавь строчку `.AddPasswordValidator<UsernameAsPasswordValidator<PhotoAppUser>>()`
в конфигурировании `Identity` и убедись, что нельзя зарегистрировать пользователя, если пароль совпадает с email.


### 1.6. Алгоритм хэширования паролей

Может понадобится изменить алгоритм хэширования паролей. Например, если есть база пользователей,
которым надо дать доступ к приложению, но при их регистрации использовался свой собственный алгоритм хэширования.

Если использовалась предыдущая версия `Identity`, то алгоритм хэширования можно просто донастроить,
указав верную версию и количество итераций при хэшировании:
```cs
services.Configure<PasswordHasherOptions>(options =>
{
    options.CompatibilityMode = PasswordHasherCompatibilityMode.IdentityV3;
    options.IterationCount = 12000;
});
```

Полностью заменить алгоритм хэширования на свой можно так:
```cs
services.AddScoped<IPasswordHasher<PhotoAppUser>, SimplePasswordHasher<PhotoAppUser>>();
```

Вот только `SimplePasswordHasher` из папки `Services` не до конца реализован.
Имея реализацию метода `HashPassword`, дореализуй метод `VerifyHashedPassword`.
Чтобы убедиться, что реализация корректна, используй тесты на `SimplePasswordHasher`,
которые находятся в том же файле.

Затем подключи `SimplePasswordHasher`, с помощью Debug убедись, что теперь используется он,
а вход под пользователями с новым алгоритмом хэширования работает.


### 1.7. Локализация

Все ошибки, которые ты видел, были на английском языке. Это не очень удобно для русскоговорящих пользователей.

В большинстве случаев тексты ошибок на английском прописаны в файлах `Identity/Pages`.
Например, в файле `Register.cshtml.cs` в классе `InputModel` с помощью атрибутов.
У любого атрибута для валидации есть свойство `ErrorMessage`, в котором можно прописать текст сообщения об ошибке
на русском языке. Таким образом эти тексты ошибок легко локализуются.
Задай текст сообщения для атрибута `Required` в свойстве `Email` класса `InputModel`.

Но кроме атрибутов для локализации нужно поменять реализацию `IdentityErrorDescriber`.
Уже есть готовая реализация, позаимствованная со StackOverflow: `Services/RussianIdentityErrorDescriber.cs`.
В файле `IdentityHostingStartup.cs` в конфигурировании `Identity` (найди `services.AddDefaultIdentity<PhotoAppUser>()`)
добавь строчку `.AddErrorDescriber<RussianIdentityErrorDescriber>()`.

Теперь попробуй зарегистрировать нового пользователя:

- Сначала заполни email, а затем сделай пустым. Ты должен увидеть сообщение об ошибке из атрибута `Required`.
  Благодаря `jquery.validate` сообщение появляется до отправки формы.
- Теперь введи корректный email, но в качестве пароля используй 6 цифр, например, 123456.
  Отправь форму. Если все правильно, то в ответ получишь сообщение
  из `RussianIdentityErrorDescriber`: «Пароль должен содержать хотя бы один символ в нижнем регистре»

Как локализовать весь остальной пользовательский интерфейс ясно: надо локализовывать файлы из папки `Identity/Pages`.
Сейчас, по понятным причинам, этого делать не нужно.


## 2. Сессии

После успешной аутентификации информация о пользователе по умолчанию хранится в cookie.
Браузер постоянно передает эту cookie на сервер и за счет этого все действия пользователя можно авторизовать.


По умолчанию все работает некоторым образом. Настройки по умолчанию можно посмотреть тут:
https://docs.microsoft.com/ru-ru/aspnet/core/security/authentication/identity-configuration#cookie-settings

Давай донастроим. Для этого:

1. Скопируй явную конфигурацию из документации в `IdentityHostingStartup.cs`.
2. Выстави `options.Cookie.Name` значение `"PhotosApp.Auth"`, чтобы сессия хранилась в cookie с известным именем.
3. Обрати внимание на настройку `options.Cookie.HttpOnly = true`. Это значит, что cookie не будет доступна
клиентским скриптам, что обычно правильно и защищает пользователя от атак со скриптов.
4. Настройка `options.SlidingExpiration = true` означает, что сессия не протухнет,
пока пользователь активно использует приложение. Это тоже хорошее поведение.

Теперь залогинься под любым пользователем и найди в меню приложения ссылку на страницу Decode и перейди по ней.
На этой странице аутентификационная кука расшифровывается, а затем информация из нее выводится.
Ниже на странице выводится информация о пользователе из поля `User` контроллера, т.е. как ее видят контроллеры.
Видно, что сейчас в cookie и в `User` хранится одна и та же информация.


Посмотри `/Views/Shared/_IdentityDecodePartial.cshtml`, чтобы понять, как можно достать данные о пользователе
из cookie и из `User`. Запоминать тонкости реализации не нужно.

Стоит убедиться, что данные в cookie защищаются с помощью `IDataProtector`, реализацию которого можно задать.
В частности, чтобы cookie зашифровывались по некоторому алгоритму с известным серверу ключом при создании
и расшифровывались при использовании.

Также стоит разобраться с используемыми понятиями:

- Обрати внимание, что «пользователь» (`User`) может включать в себя несколько «личностей» (`Identities`).
Это нужно, потому что информация о пользователе может приходить из разных источников (cookie, headers и т.д.)
и может быть разной. В одном случае — это Вики, в другом — Скарлетт Йоханссон. И все личности — это один пользователь.
- Также обрати внимание, что при расшифровке cookie из нее достается `AuthenticationTicket`, т.е. «удостоверение».
«Удостоверение» хранит разную информацию и в частности свойство `Principal`.
«Приципал» — это лицо, от чьего имени может действовать предъявитель удостоверения.
В данном случае браузер, который отправил нашему сервису cookie.
- Наконец, еще одно понятие — claims. Это некоторые «утверждения» про «личность», представляющие из себя
пары ключ-значение. Например, «возраст = 72», «роль = режиссер», «гражданство = США».
На основании этих «утверждений» пользователю могут быть доступны те или иные действия в приложении.


Если надо хранить в сессии много данных о пользователе, то аутентификационная кука станет достаточно большой.
Неэкономично заставлять браузер передавать все эти данные с каждым запросом в виде cookie.
В этом случае можно хранить данные о сессии на сервере.

Для хранения сессии на сервере хорошо подойдет распределенной InMemory хранилище.
InMemory — для скорости, распределенное — для отказоустойчивости. Например, подойдет Redis.
Но для учебных целей воспользуемся все тем же Sqlite.

Готовые хранилища уже реализованы в `Services/EntityTicketStore.cs` и `Services/MemoryCacheTicketStore.cs`
Посмотри как они устроены.

`MemoryCacheTicketStore` проще, потому что хранит всю информацию о сессиях в оперативной памяти.
Это очень быстро, но перезагрузка веб-сервера заставит пользователей входить заново. Не надо так.

Поэтому подключать стоит `EntityTicketStore`, сделай это:
```cs
services.AddTransient<EntityTicketStore>();
services.ConfigureApplicationCookie(options =>
{
    var serviceProvider = services.BuildServiceProvider();
    options.SessionStore = serviceProvider.GetRequiredService<EntityTicketStore>();
    /* добавленный ранее код конфигурации */
});
```

Так как это хранилище использует Entity Framework Core, надо его сконфигурировать,
а затем выполнить миграцию и обновление базы данных:

1. Сконфигурируй `TicketsDbContext` в `IdentityHostingStartup.cs` аналогично `UsersDbContext`
2. Добавь значение для `TicketsDbContextConnection` в `appsettings.json`,
причем можешь снова использовать `PhotosApp.db` в качестве файла БД
3. `dotnet ef migrations add Tickets --context TicketsDbContext`
4. `dotnet ef database update --context TicketsDbContext`,
либо добавить `dbContext.Database.Migrate()` в `Data/DataExtensions.cs`

После подключения снова залогинься и перейди на страницу Decode.
Обрати внимание, что теперь в аутентификационной куке хранится только идентификатор сессии.
Вся остальная информация о пользователе хранится и незаметно достается из Sqlite.


## 3. Роли и политики

### 3.1. Роли

Не весь функционал должен быть доступен каждому пользователю.
Требуется ограничить права различных групп пользователей.


Один из способов — ввести систему ролей.
Добавь новую роль `Dev`, присвой ее уже имеющемуся пользователю `dev@gmail.com` и сделай так,
чтобы только пользователи с ролью `Dev` имели доступ к `DevController`.

Подсказки:

- В конфигурировании `Identity` в `IdentityHostingStartup.cs` надо добавить `.AddRoles<IdentityRole>()`
сразу после `.AddDefaultIdentity<PhotoAppUser>()`
- Нужно создать Роль в БД. Код создания роли уже есть в методе `SeedWithSampleRolesAsync`.
Сделай так, чтобы метод `SeedWithSampleRolesAsync` из `DataExtensions.cs` выполнялся при создании БД,
т.е. в методе `PrepareDB`, причем до `SeedWithSampleUsersAsync`.
Тебе понадобится `RoleManager<IdentityRole>`: достань его из `ServiceProvider`.
- Добавить пользователю новую роль можно командой `await userManager.AddToRoleAsync(user, "RoleName")`
- Защитить метод или контроллер можно с помощью атрибута с параметром: `[Authorize(Roles = "RoleName")]`

Когда закончишь, убедись, что только пользователь `dev@gmail.com` может пользоваться страницей Decode,
а у других пользователей возникает сообщение об ошибке.


Будет хорошо, если пользователи, которым недоступен Decode вообще не будут видеть ссылку на страницу. Сделай так!
Проверить во view, что у текущего пользователя есть роль можно так: `User.IsInRole("RoleName")`


### 3.2. Политики

Более гибко настраивать права пользователей позволяют политики на основании различных claims (утверждений) пользователя.

Сейчас любому пользователю при заходе на страницу отдельной фотографии доступно изменение подписи к фотографии.
Сделай так, чтобы возможность редактировать подписи к фотографиям была доступна только beta-тестерам.

Для начала в `IdentityHostingStartup.cs` нужно зарегистрировать некоторую политику:
```cs
services.AddAuthorization(options =>
{
    options.AddPolicy(
        "Beta",
        policyBuilder =>
        {
            policyBuilder.RequireAuthenticatedUser();
            policyBuilder.RequireClaim("testing", "beta");
        });
});
```

Эта политика требует, чтобы пользователь был аутентифицирован и у него был claim `testing` со значением `beta`.
Сейчас таких пользователей нет.

Сделай так, чтобы при старте приложения пользователю `vicky` добавлялся такой claim.
Подсказка: `await userManager.AddClaimAsync(user, new Claim("claimType", "claimValue"))`
Claim, добавленные таким образом хранятся в отдельной таблице.
Можешь в этом убедиться с помощью https://sqliteonline.com/.

Теперь защити действие `EditPhoto` в `PhotoController` с помощью атрибута `[Authorize(Policy = "Beta")]`.


Когда закончишь, убедись, что только пользователь `vicky@gmail.com` может редактировать подписи к фотографиям,
а у других пользователей возникает сообщение об ошибке.


Будет хорошо, если пользовали, которым недоступно редактирование подписей вообще не видели ссылки на это действие.
Проверить во view выполнение политики для пользователя можно так:
```cshtml
(await AuthorizationService.AuthorizeAsync(User, "PolicyName")).Succeeded
```
Только надо добавить в начале view подключение зависимостей:
```cshtml
@using Microsoft.AspNetCore.Authorization
@inject IAuthorizationService AuthorizationService
```
Скрой действие «Изменить подпись» на странице отдельной фотографии.


Когда закончишь с этим добавь еще одну политику: пусть только платым пользователям будет доступна загрузка фотографий.
Назови политику `CanAddPhoto`, в качестве типа claim используй `subscription`, в качестве значения `paid`.
Аналогично предыдущей политике, защити методы `PhotoController` для загрузки фотографий.
и скрой ссылку «Добавить фото» в меню приложения. Также скрой ссылку на метод `AddPhoto` в `Index.cshtml`,
которая показывается, когда у пользователя нет фотографий.

А вот claim в пользователя надо выставить иначе. Путь он не хранится отдельно в таблице, а вычисляется по свойствам из `PhotoAppUser`.

Для этого:

1. Добавь в класс `PhotoAppUser` булево свойство `Paid`.
2. Создай миграцию, т.к. надо добавить новую колонку в таблицу пользователей:
`dotnet ef migrations add Paid --context UsersDbContext`
2. Разбери generic-параметр `TUser` в методе `SeedWithSampleUsersAsync`, заменив его использования
на тип `PhotoAppUser`.
3. Сделай так, чтобы пользователю `cristina` при создании в свойство `Paid` выставлялось значение `true`. 
4. Самое важное! Допиши класс `CustomClaimsPrincipalFactory`
в файле `Services/Authorization/CustomClaimsPrincipalFactory.cs`.
Сначала замени во всем файле использование `IdentityUser` на `PhotoAppUser`, 
а затем сделай так, чтобы пользователю с `Paid == true` выставлялся claim `subscription` со значением `paid`.
5. Зарегистрируй фабрику в `IdentityHostingStartup.cs` в конфигурации `Identity`,
добавив для этого вызов `.AddClaimsPrincipalFactory<CustomClaimsPrincipalFactory>()`
в цепочку вызовов после `.AddDefaultIdentity<PhotoAppUser>()`.

Убедись, что пользователю `cristina` доступно добавление фото, `vicky` не доступно.

Как видишь, определив собственную `UserClaimsPrincipalFactory`,
можно выставить пользователю нужные claims по произвольным правилам «на лету»,
т.е. без хранения самих claims в базе данных.


### 3.3. Обработчик для требования

В приложении до сих пор любой аутентифицировавшийся пользователь может открыть любую фотографию,
если у него будет прямая ссылка до нее.

Убедись в этом:

1. Зайди под пользователем `vicky`
2. Перейди на страницу с одной фотографией и сохрани URL страницы
3. Выполни logout и зайди под пользователем `cristina`
4. Используй сохраненный URL, чтобы открыть фотографию. Она доступна другому пользователю!

Чтобы создать политику, которая бы запрещала доступ к фото другим пользователям,
потребуется `AuthorizationHandler`.


Для начала создай новую политику `MustOwnPhoto`, а в ней потребуй два условия:
```cs
policyBuilder.RequireAuthenticatedUser();
policyBuilder.AddRequirements(new MustOwnPhotoRequirement());
```

`MustOwnPhotoRequirement` — некоторое требование, которое будет проверяться динамически с помощью обработчика.
Обработчик для этого требования уже добавлен. Это класс `MustOwnPhotoHandler`. Он может быть
обработчиком требования, потому что наследуется от класса `AuthorizationHandler<MustOwnPhotoRequirement>`.

Но, чтобы обработчик создавался его надо зарегистрировать в качестве `IAuthorizationHandler`:
```cs
services.AddScoped<IAuthorizationHandler, MustOwnPhotoHandler>();
```

Защити действия `GetPhoto`, `EditPhoto`, `DeletePhoto` в `PhotoController` с помощью новой политики.
Заметь, что это нормально использовать несколько атрибутов `Authorize` у метода.
В этом случае для выполнения действия должны быть выполнены требования каждого атрибута.

Допиши `MustOwnPhotoHandler` так, чтобы требование выполнялось,
если текущий пользователь является владельцем фотографии.


### 4. Аутентификация через Google

ASP.NET Core включает встроенную поддержку для OAuth, за счет чего к нему
легко подключить внешних провайдеров аутентификации.
А для некоторых, включай Google и Facebook есть даже готовые методы,
позволяющие подключить провайдера, написав пару строчек.

Добавь следующий код в `IdentityHostingStartup.cs`:
```cs
services.AddAuthentication()
    .AddGoogle("Google", options =>
        {
            options.ClientId = context.Configuration["Authentication:Google:ClientId"];
            options.ClientSecret = context.Configuration["Authentication:Google:ClientSecret"];
        });
```
Это почти все, что нужно, чтобы заработала аутентификация через Google в случае `Identity`,
потому что отображение нужных кнопок для внешних провайдеров аутентификации уже реализовано.


Осталось только зарегистрировать приложение в Google, получить Client ID и Client Secret,
а затем положить их в настройки, чтобы следующие строчки работали корректно:
```cs
options.ClientId = configuration["Authentication:Google:ClientId"];
options.ClientSecret = configuration["Authentication:Google:ClientSecret"];
```

Для этого:

1. Перейди на страницу https://developers.google.com/identity/sign-in/web/sign-in#before_you_begin
2. Нажми кнопку «Configure Project»
3. Введи имя нового проекта
4. Выбери опцию Web server и введи https://localhost:44398/signin-google в качестве «Authorized redirect URIs».
Введи https://localhost:5001/signin-google, если запускаешь приложение через dotnet CLI.
5. Нажми на кнопку «Create», а затем получи Client ID и Client Secret

`/signin-google` — это путь, по которому Google отправит данные пользователя
после успешной аутентификации. Такой адрес используется по умолчанию в ASP.NET Core, соответственно,
данные от Google будут успешно получены и обработаны Authentication Middleware.


Client ID и Client Secret используются авторизации приложения в Google.
Их можно сохранить в `appsettings.json`, по ключам `Authentication:Google:ClientId`
и `Authentication:Google:ClientSecret` и все будет работать.
Но файлы, хранящиеся в репозитории, в том числе `appsettings.json` — это плохое место для хранения паролей и секретов.

Поэтому лучше воспользоваться специальным хранилищем для секретов вот так:
```bash
dotnet user-secrets set "Authentication:Google:ClientId" "<client id>"
dotnet user-secrets set "Authentication:Google:ClientSecret" "<client secret>"
```

В этом случае значения будут сохранены тут:
- `%APPDATA%\Microsoft\UserSecrets\<user_secrets_id>\secrets.json` в Windows
- `~/.microsoft/usersecrets/<user_secrets_id>/secrets.json` в Linux, Mac

В Visual Studio секретами можно управлять, если кликнуть правой кнопкой мыши по проекту в «Solution Explorer»
и выбрать пункт «Manage Secrets».

После сохранения реквизитов в хранилище для секретов не обязательно их удалять из `appsettings.json`,
потому что значения из хранилища более приоритетны и перетрут значения из `appsettings.json`.


Далее своими проектами в Google можно будет управлять через специальный «пульт»:
https://console.developers.google.com/apis/credentials


После верного задания Client ID и Client Secret аутентификация через Google
должна появиться на странице логина и корректно работать.


### 5. Письма

Хорошая практика — предлагать пользователю подтвердить адрес своей электронной почты,
чтобы случайная опечатка при вводе email или забытый пароль не приводили к потере доступа к аккаунту.

`Identity` пытается отправлять письма с кодом подтверждения всем новым пользователям с помощью `IEmailSender`.
По умолчанию он реализован так, что ничего не отправляет.


В `Services/SimpleEmailSender` есть реализация, которая умеет отправлять письма через внешний SMTP-сервер.
Подключи ее:
```cs
services.AddTransient<IEmailSender, SimpleEmailSender>(serviceProvider =>
    new SimpleEmailSender(
        serviceProvider.GetRequiredService<ILogger<SimpleEmailSender>>(),
        serviceProvider.GetRequiredService<IWebHostEnvironment>(),
        context.Configuration["SimpleEmailSender:Host"],
        context.Configuration.GetValue<int>("SimpleEmailSender:Port"),
        context.Configuration.GetValue<bool>("SimpleEmailSender:EnableSSL"),
        context.Configuration["SimpleEmailSender:UserName"],
        context.Configuration["SimpleEmailSender:Password"]
    ));
```
Большинство настроек для подключения к SMTP-серверу Google уже прописаны в `appsettings.json`.
Пропиши в файл или в User Secrets адрес своей электронной почты Google в `UserName`
и соответствуйщий пароль в `Password`.

Также, чтобы «стороннее приложение», которое ты пишешь, смогло отправлять письма придется
понизить уровень безопасности аккаунта на странице https://myaccount.google.com/lesssecureapps

Зарегистрируй нового пользователя с существующим email и убедись, что на него пришло письмо
для подтверждения адреса электронной почты.


Если нужно, чтобы без подтверждения email нельзя было войти в аккаунт,
следует изменить настройку `SignIn.RequireConfirmedEmail` для `Identity`.
Но в обучающем проекте нам это не нужно.


### 6. Json Web Token

Сейчас тебе предстоит добавить нестандартный способ аутентификации в сервисе.
Работать он должен так: пользователь переходит по секретному URL, где ему выставляется cookie с JWT-токеном.
Этот короткоживущий токен дает доступ разработчика к сервису на полминуты.


Найди и открой `HackController`. В методе `GenerateToken` с суперсекретным адресом вызывается генерация JWT-токена.
Затем этот токен добавляется в cookie.

Для начала надо доработать генерацию токена в методе `TemporaryTokens.GenerateEncoded`.

1. Сделай так, чтобы токен не действовал до текущего момента.
Для этого надо передать текущее время в UTC в `notBefore`.
2. Сделай так, чтобы токен действовал всего лишь 30 секунд, задав правильно `expires`.
3. Заполни `claims`:
    - Утверждению `ClaimTypes.NameIdentifier` (идентификатор пользователя) задай значение `Guid.NewGuid().ToString()`
    - Утверждению `ClaimsIdentity.DefaultNameClaimType` (имя пользователя) задай какое-нибудь значение
    - Утверждению `ClaimsIdentity.DefaultRoleClaimType` (роль пользователя) задай значение `"Dev"`
4. Чтобы токен нельзя было подделать можно добавить зашифрованный с помощью симметричного ключа отпечаток.
В этом случае получатель токена, если у него есть ключ шифрования, сможет построить свои отпечаток
и сравнить с отпечатком, добавленным издателем. Если отпечатки не совпадут, значит токен поддельный.
Воспользуйся алгоритмом HMAC SHA-256.
SHA-256 — хэш-функция, HMAC — алгоритм, использующий симметричный ключ и некоторую хэш-функцию для получения отпечатка.
Все уже реализовано, надо только правильно задать `signingCredentials`.
Используй ключ из свойства `TemporaryTokens.SigningKey`, а имя алгоритма есть в константе `SecurityAlgorithms.HmacSha256`.

Теперь, если обратиться по пути `/hack/super_secret_qwe123` будет возвращен токен. Он также окажется в cookie.

Получи и расшифруй этот токен с помощью сервиса https://jwt.io/.
Передай зашифрованный вариант и убедись, что в «PAYLOAD» там заданные тобой данные.

Добейся того, чтобы появилась надпись «Signature Verified».
Алгоритм подписи должен автоматически выставиться в HS256, т.к. он передается в заголовке токена,
так что осталось передать правильный ключ симметричного шифрования в блоке «VERIFY SIGNATURE».


Итак, правильный JWT-токен уже можно получить в виде cookie.
Но пока приложение никак на это не реагирует. Надо это исправить.

Добавь следующий код в `IdentityHostingStartup.cs`:
```cs
services.AddAuthentication()
    .AddJwtBearer(options =>
    {
        options.RequireHttpsMetadata = false;
        options.TokenValidationParameters = new TokenValidationParameters
        {
        };
    });
```
После этого аутентификация по JWT-токены в какой-то степени начнет поддерживаться. Но надо донастроить.

В `TokenValidationParameters`:

1. Выстави `ValidateIssuer` и `ValidateAudience` в `false`,
потому что информация об издателе и получателях токена не добавлялась.
2. Выстави `ValidateLifetime` в `true`, чтобы старые токены не работали.
Также задай `ClockSkew = TimeSpan.Zero`. Дело в том, что токены генерируются и проверяются обычно на разных серверах
и время на них может отличаться. Поэтому при проверке токенов допускается погрешность в несколько минут.
Это правильно, но для корректной работы токена с временем жизни в полминуты нужно от погрешности отказаться.
3. Выстави `ValidateIssuerSigningKey` в `true`, чтобы проверялся отпечаток токена.
В `IssuerSigningKey` передай использованный при создании отпечатка ключ.

Еще один нюанс — откуда будет доставаться токен.
Обычно JWT-токены передаются в заголовке `Authorization` и подписью `Bearer`, которая указывает,
что авторизация будет с помощью токена «на предъявителя».
Выглядит это примерно так:
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.Et9HFtf9R3GEMA0IICOfFMVXY7kkTX1wr4qCyhIf58U
```

*Замечание. Другим распространенным способом авторизации является Basic, в которой в заголовке Authorization*
*передается подпись Basic, после чего идет строка логин:пароль (например, aladdin:opensesame),*
*закодированная с помощью base64.*
*Выглядит это примерно так:*
```
Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
```

Сейчас же токен хранится в cookie. Но можно подсказать ASP.NET Core откуда брать токен вот так:
```cs
options.Events = new JwtBearerEvents
{
    OnMessageReceived = c =>
    {
        c.Token = c.Request.Cookies["NameOfCookieWithToken"];
        return Task.CompletedTask;
    }
};
```
Только не забудь передать правильное имя cookie.


Аутентификация по JWT-токенам теперь должна работать.

Проверь, что токен правильно генерируется и преобразуется в `User`:

1. Перейди по секретному адресу `/hack/super_secret_qwe123` и получи токен.
2. Перейди на секретную страницу декодирования пользователя `/hack/decode`,
которая требует авторизацию токеном и убедись, что пользователь заполнен.


Пора настроить авторизацию. Сейчас она настроена использовать только `Identity`.
Надо сделать так, чтобы авторизация поддерживала оба способа аутентификации: `Identity` и `JwtBearer`.

Сначала немного теории. У каждого способа аутентификации есть идентификатор — схема.
Для `Identity` значение схемы по умолчанию хранится в константе `IdentityConstants.ApplicationScheme`.
Для `JwtBearer` значение схемы по умолчанию хранится в константе `JwtBearerDefaults.AuthenticationScheme`.
Если надо добавить поддержку нескольких видов `JwtBearer`, то можно задать схему явно:
```cs
services.AddAuthentication()
    .AddJwtBearer("SomeJWT", options => { /* */ })
    .AddJwtBearer("AnotherJWT", options => { /* */ });
```

`Identity` тоже добавляет свой способ аутентификации при вызове `services.AddDefaultIdentity<PhotoAppUser>()`.
В `AddDefaultIdentity` скрыт следующий код:
```cs
services.AddAuthentication(o =>
{
    o.DefaultScheme = IdentityConstants.ApplicationScheme;
    o.DefaultSignInScheme = IdentityConstants.ExternalScheme;
}).AddIdentityCookies();
```
`AddIdentityCookies` — это добавляемый способ аутентификации.
А настройка `DefaultScheme` — это та схема, которая будет использоваться по умолчанию для различных операций.
В том числе атрибутом `[Authorize]`. И `AddDefaultIdentity` выставляет `Identity` для использования по умолчанию.


`Identity` в качестве схемы по умолчанию — это нормально, пусть так и будет.
А надо сделать так, чтобы `[Authorize]` стал поддерживать новый способ аутентификации.
Для этого надо переопределить политику авторизации по умолчанию вот так:
```cs
services.AddAuthorization(options =>
{
    options.DefaultPolicy = new AuthorizationPolicyBuilder(
        JwtBearerDefaults.AuthenticationScheme,
        IdentityConstants.ApplicationScheme)
        .RequireAuthenticatedUser()
        .Build();
        /* добавленный ранее код конфигурации */
}
```
Новая политика использует и `Identity`, и `JwtBearer`.


Пришло время для проверки:

1. Перейди по секретному адресу `/hack/super_secret_qwe123` и получи токен.
2. Перейди на главную страницу и убедись, что доступна ссылка «Decode», как и всем разработчикам.
3. Перейди по ней и убедись, что сам метод пока еще не доступен.


Настройка политики по умолчанию никак не влияет на атрибуты с дополнительными настройками,
в том числе на `[Authorize(Roles = "Dev")]`, поэтому страница по ссылка «Decode» еще не работает.

Быстрый способ починить — дополнительно к роли перечислить в атрибуте допустимые схемы через запятую:
```cs
[Authorize(Roles = "Dev", AuthenticationSchemes = "Identity.Application,Bearer")]
```
Но так делать сейчас не надо.

Качественный способ решить эту проблему — везде для конфигурирования авторизации использовать политики,
как ранее использовали `[Authorize(Policy = "Beta")]`. Глядя на политику по умолчанию и другие политики,
добавь политику `"Dev"`. Тебе пригодятся методы `RequireRole` и `AddAuthenticationSchemes` у `policyBuilder`.
Затем воспользуйся этой политикой в `DevController`. После этого ссылка «Decode» должна заработать.
Причем как для аутентификации по токену, так и для пользователя `dev@gmail.com`.

*Замечание. Порядок добавления схем в политику имеет значение.*
*Чтобы получить нужный результат добавь сначала `JwtBearerDefaults.AuthenticationScheme`,*
*а затем `IdentityConstants.ApplicationScheme`.*


Итоговая проверка:

1. Перейди по секретному адресу `/hack/super_secret_qwe123` и получи токен.
2. Залогинься под пользователем `vicky@gmail.com`.
3. Перейди на главную страницу и убедись, что отображаются фотографии пользователя `vicky@gmail.com`.
4. Убедись, что доступна ссылка «Decode», как и всем разработчикам.
5. Перейди по ссылке «Decode» и убедись, что пользователь (ClaimsPrincipal) представлен
двумя личностями (ClaimsIdentity), одна из которых заполнена из токена, а другая — `vicky@gmail.com`.
