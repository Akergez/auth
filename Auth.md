# Auth

## 0. Запуск

Требуется научиться запускать приложение `PhotosApp` и убедиться, что все хорошо.

Приложение использует https, поэтому для корректной работы понадобится сертификат.
.NET Core умеет создавать сертификаты для localhost. Только надо установить такой сертификат в доверенные.
Для этого запусти команду:
```
dotnet dev-certs https --trust
```

Запусти приложение под отладкой. Должен запусться браузер и открыть стартовую страницу приложения.
Убедись, что при запуске в папке `PhotosApp` автоматически создался файл `PhotosApp.db` с базой данных Sqlite.

Открой файл `PhotosApp.db` с помощью сервиса https://sqliteonline.com/.
Убедись, что в нем есть таблица `Photos`, выведи записи из нее.


## 1. Identity

### 1.1. Scaffolding

Требуется сгенерировать код `Identity`, а затем ее корректно подключить к приложению `PhotosApp`.

*Scaffolding (англ. строительные леса) — генерация кода по заданной разработчиком спецификации.*

Прежде всего потребуется установить новый инструмент для .NET Core CLI — генератор кода:
```
dotnet tool install -g dotnet-aspnet-codegenerator
```

Кроме того, в проект надо добавить NuGet-пакеты для кодогенерации.
Выполни в папке с проектом PhotosApp:
```
dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design
dotnet add package Microsoft.EntityFrameworkCore.Design
```

Наконец, можно выполнить команду генерации кода `Identity` (также в папке с проектом PhotosApp):
```
dotnet aspnet-codegenerator identity -dc UsersDbContext -u PhotoAppUser -sqlite
```

Дополнительные параметры команды указывают:

- имя `DbContext`, который будет использоваться для хранения информации о пользователях,
- класс пользователя, хранимого в базе данных,
- что, в качестве базы данных надо использовать Sqlite, а не SQL Server.


В проекте `PhotosApp` в папке `Areas/Identity` был сгенерирован требующийся код.

`Area` в ASP.NET Core MVC — это в каком-то смысле подприложение с собственной адресацией.
В случае `Identity` все адреса страниц будут иметь префикс `/Indentity`, после которого будет обычный путь до страницы.

Посмотри структуру папки  `Areas/Identity`.
Обрати внимание на файл `Areas/Identity/IdentityHostingStartup.cs`.
Код из него будет автоматически запускаться после `Startup.cs` и завершать конфигурирование.
Также обрати внимание, что страницы сгенерированы по технологии `Razor Pages`.
В отличие от MVC, где «разметка» (View) и «обработка» (Controller) находится в разных местах,
здесь все находится в двух соседних файлах. Например, для страницы `Identity/Pages/Account/Login.cshtml`,
разметка находится в `Login.cshtml`, а обработка в `Login.cshtml.cs`.


Чтобы `Razor Pages` заработали, надо их добавить в контейнер, а также подключить в качестве обработчиков запросов.

Код для `ConfigureServices`:
```cs
var mvc = services.AddControllersWithViews();
services.AddRazorPages();
if (env.IsDevelopment())
    mvc.AddRazorRuntimeCompilation();
```
*Замечение. Раз `AddRazorRuntimeCompilation` в подключается контексте `AddControllersWithViews`,*
*то для `AddRazorPages` можно снова не подключать.*
*Компиляция представлений на лету без перестроения всего проекта будет работать и для razor pages.*

Код для `Configure`:
```cs
app.UseEndpoints(endpoints =>
{
    endpoints.MapControllerRoute("default", "{controller=Photo}/{action=Index}/{id?}");
    endpoints.MapRazorPages();
});
```


Также в `Views/Shared` был сгенерирован `_LoginPartial.cshtml`, содержищий разметку для отображения
ссылок для регистрации/входа/выхода пользователя в меню приложения.

Ссылки регистрации/входа/выхода надо добавить в меню приложения.
Для этого открой `Views/Shared/_Layout.cshtml` и добавь вставку `_LoginPartial.cshtml` с помощью tag-хелпера
сразу после других ссылок:
```cshtml
<ul class="navbar-nav mr-auto">
    ...
</ul>
<partial name="_LoginPartial"/>
```

Можешь убедиться, что ссылки появились и при переходе по ним открываются страницы `Identity`.

Только ничего не работает, потому что пользователей нет, да и таблица базы данных для них еще не создана.


### 1.2. Миграции

Для манипулирования базой данных нужно установить инструмент Entity Framework Core для .NET CLI:
```
dotnet tool install --global dotnet-ef
```

В коде появился новый контекст. Чтобы обновить БД для хранения данных из него, надо создать миграцию:
```
dotnet ef migrations add Users --context UsersDbContext
```
Миграция — это план обновления. Его можно применять к БД, которыми будет пользоваться приложение.

Чтобы миграция успешно создалась:

1. Приложение должно компилироваться без ошибок,
2. При старте приложения не должно быть ошибок,
т.е. код конфигурирования (в `Startup.cs` и `IdentityHostingStartup.cs`) должен работать корректно
3. Приложение не должно быть запущенным.
Все это нужно, чтобы команда миграции смогла построить и запустить проект,
а затем получить через рефлексию всю необходимую информацию о контексте.

Если при запуске миграции встретилась такая замысловатая ошибка про «design time», проверь предыдущие три пункта.
`Unable to create an object of type 'UsersDbContext'. For the different patterns supported at design time, see https://go.microsoft.com/fwlink/?linkid=851728`


После создания миграции ее надо запустить на имеющейся базе данных Sqlite.
Сделай это с помощью следующей команды:
```
dotnet ef database update --context UsersDbContext
```
Теперь база данных обновлена и в ней можно хранить информацию о пользователях.
Посмотри с помощью https://sqliteonline.com/ какие таблицы были созданы. Заметь, что их достаточно много.


Для целей разработки можно вместо `dotnet ef database update` использовать такой вызов метода:
```cs
dbContext.Database.Migrate()
```
Здесь `dbContext` — экземпляр класса-наследника `DbContext`.

Посмотри как этот метод используется в файле `Data/DataExtensions.cs` для `PhotosDbContext`,
и напиши аналогичный код для `UsersDbContext`.
В результате, если файл `PhotosApp.db` удален, то при запуске приложения
он автоматически восстановится со всеми таблицами.


Теперь надо добавить тестовых пользователей.
Это умеет делат метод `SeedWithSampleUsersAsync` из `Data/DataExtensions.cs`.
Вызови его в `PrepareDB`, чтобы при старте приложения создавались тестовые пользователи.
Подсказка: `UserManager<PhotoAppUser>` можно достать из `ServiceProvider`.


### 1.3. Аутентификация

Чтобы под пользователем можно было зайти, подключи middleware аутентификации `UseAuthentication`
 и middleware авторизации `UseAuthorization` в `Startup.cs`.
Их вызов обязательно должен быть после подключения middleware для определения обработчика запроса (`UseRouting`),
но перед подключением middleware для выполнения запроса (`UseEndpoints`).
Это позволит слою `UseAuthorization` проверить пользователя на соответствие требованиям обработчика,
который стал известен после `UseRouting`, и отменить выполнение обработки в `UseEndpoints`,
если у пользователя не хватает прав. Слой `UseAuthentication` также пользуется информацией из `UseRouting`.
Должно получиться так:
```cs
app.UseRouting();

app.UseAuthentication();
app.UseAuthorization();

app.UseEndpoints(endpoints => ...);
```


Теперь попробуй зайти под пользователем `cristina`. Пароль можно найти в `Data/DataExtensions.cs`.


Но даже если зайти под нужным пользователем, его фотки не будут показываться, пока не поправить `PhotoController`.
Измени метод `GetOwnerId` так, чтобы он возвращал идентификатор залогиненного пользователя, а не идентификатор `vicky`:
```cs
private string GetOwnerId()
{
    return User.FindFirstValue(ClaimTypes.NameIdentifier);
}
```


Снова зайди под `cristina`, а затем под `vicky`. Фотографии должны быть разными.


Осталась пара нюансов.

1. При заходе на страницы управления аккаунтом (кликни на имя пользователя в меню приложения, чтобы туда попасть)
показывается неправильная шапка страницы.
Чтобы починить в файле `/Areas/Identity/Pages/Account/Manage/_Layout.cshtml` поменяй `Layout`.
Корректное значение для приложения — `"/Views/Shared/_Layout.cshtml"`

2. Logout работает некорректно. После него не происходит перехода на главную страницу приложения,
а в верхнем меню остается имя пользователя. Это происходит потому, что в `_LoginPartial.cshtml`
указан некорректный `asp-route-returnUrl`. Должен быть `@Url.Action("Index", "Photo", new { area = "" })`.


### 1.4. Авторизация

Теперь надо сделать, чтобы анонимный пользователь автоматически пересылался на страницу входа
при выполнении любых действий с фотографиями. Доступной должна остаться только главная страница.

Для этого достаточно пометить атрибутом `[Authorize]` все методы или контроллеры, которые требуется защитить.
Если пометить атрибутом `[Authorize]` контроллер, но надо разрешить некоторый метод, то метод помечается
атрибутом `[AllowAnonymous]`.

Защити все действия над фотографиями из `PhotoController`, кроме `Index`.


### 1.5. Требования к паролям

Настройки по умолчанию для паролей хороши:

- есть требования на длину и используемые символы,
- пароли не хранятся о открытом виде, а хэшируются с солью.

Но такие настройки не всегда подходят.

В большинстве случаев достаточно конфигурирования. Начни с этого.

Настройки по умолчанию для паролей можно посмотреть тут:
https://docs.microsoft.com/ru-ru/aspnet/core/security/authentication/identity-configuration#password

Заодно в том же документе можно посмотреть настройки по умолчанию для входа:
https://docs.microsoft.com/ru-ru/aspnet/core/security/authentication/identity-configuration#sign-in

Чтобы облегчить себе жизнь во время прохождения блока:

1. Скопируй явную конфигурацию из документации в `IdentityHostingStartup.cs`
2. Выстави настройки для паролей `RequireDigit`, `RequireNonAlphanumeric`,
и `RequireUppercase` в `false`. Оставь `RequireLowercase` в `true`!
3. Также выстави в настройках входа `RequireConfirmedAccount` в `false`.
Убедись, что нигде в `IdentityHostingStartup.cs` больше `RequireConfirmedAccount` в `true` не выставляется.

В реальных проектах так делать не надо, это только для разработки и обучения :)

При желании можешь поменять пароли для `vicky`, `cristina` и `dev` в файле `DataExtensions.cs`, чтобы было проще.
Зарегистрируй нового пользователя с простым паролем из 6 символов: у тебя должно получиться.
Затем выйди из него и зайди снова. Вход должен получиться, несмотря на то, что ты не подтверждал email.

Все же может потребоваться добавить новые правила проверки паролей.
Например, проверить, что новый пароль не совпадает с логином пользователя.
Проверка уже реализована в `Services/UsernameAsPasswordValidator.cs`. Изучи ее код.
А затем добавь строчку `.AddPasswordValidator<UsernameAsPasswordValidator<PhotoAppUser>>()`
в конфигурировании `Identity` и убедись, что нельзя зарегистрировать пользователя, если пароль совпадает с email.


### 1.6. Алгоритм хэширования паролей

Может понадобится изменить алгоритм хэширования паролей. Например, если есть база пользователей,
которым надо дать доступ к приложению, но при их регистрации использовался свой собственный алгоритм хэширования.

Если использовалась предыдущая версия `Identity`, то алгоритм хэширования можно просто донастроить,
указав верную версию и количество итераций при хэшировании:
```cs
services.Configure<PasswordHasherOptions>(options =>
{
    options.CompatibilityMode = PasswordHasherCompatibilityMode.IdentityV3;
    options.IterationCount = 12000;
});
```

Полностью заменить алгоритм хэширования на свой можно так:
```cs
services.AddScoped<IPasswordHasher<PhotoAppUser>, SimplePasswordHasher<PhotoAppUser>>();
```

Вот только `SimplePasswordHasher` из папки `Services` не до конца реализован.
Имея реализацию метода `HashPassword`, дореализуй метод `VerifyHashedPassword`.
Чтобы убедиться, что реализация корректна, используй тесты на `SimplePasswordHasher`,
которые находятся в том же файле.

Затем подключи `SimplePasswordHasher`, с помощью Debug убедись, что теперь используется он,
а вход под пользователями с новым алгоритмом хэширования работает.


### 1.7. Локализация

Все ошибки, которые ты видел, были на английском языке. Это не очень удобно для русскоговорящих пользователей.

В большинстве случаев тексты ошибок на английском прописаны в файлах `Identity/Pages`.
Например, в файле `Register.cshtml.cs` в классе `InputModel` с помощью атрибутов.
У любого атрибута для валидации есть свойство `ErrorMessage`, в котором можно прописать текст сообщения об ошибке
на русском языке. Таким образом эти тексты ошибок легко локализуются.
Задай текст сообщения для атрибута `Required` в свойстве `Email` класса `InputModel`.

Но кроме атрибутов для локализации нужно поменять реализацию `IdentityErrorDescriber`.
Уже есть готовая реализация, позаимствованная со StackOverflow: `Services/RussianIdentityErrorDescriber.cs`.
В файле `IdentityHostingStartup.cs` в конфигурировании `Identity` (найди `services.AddDefaultIdentity<PhotoAppUser>()`)
добавь строчку `.AddErrorDescriber<RussianIdentityErrorDescriber>()`.

Теперь попробуй зарегистрировать нового пользователя:

- Сначала заполни email, а затем сделай пустым. Ты должен увидеть сообщение об ошибке из атрибута `Required`.
  Благодаря `jquery.validate` сообщение появляется до отправки формы.
- Теперь введи корректный email, но в качестве пароля используй 6 цифр, например, 123456.
  Отправь форму. Если все правильно, то в ответ получишь сообщение
  из `RussianIdentityErrorDescriber`: «Пароль должен содержать хотя бы один символ в нижнем регистре»

Как локализовать весь остальной пользовательский интерфейс ясно: надо локализовывать файлы из папки `Identity/Pages`.
Сейчас, по понятным причинам, этого делать не нужно.


## 2. Сессии

После успешной аутентификации информация о пользователе по умолчанию хранится в cookie.
Браузер постоянно передает эту cookie на сервер и за счет этого все действия пользователя можно авторизовать.


По умолчанию все работает некоторым образом. Настройки по умолчанию можно посмотреть тут:
https://docs.microsoft.com/ru-ru/aspnet/core/security/authentication/identity-configuration#cookie-settings

Давай донастроим. Для этого:

1. Скопируй явную конфигурацию из документации в `IdentityHostingStartup.cs`.
2. Выстави `options.Cookie.Name` значение `"PhotosApp.Auth"`, чтобы сессия хранилась в cookie с известным именем.
3. Обрати внимание на настройку `options.Cookie.HttpOnly = true`. Это значит, что cookie не будет доступна
клиентским скриптам, что обычно правильно и защищает пользователя от атак со скриптов.
4. Настройка `options.SlidingExpiration = true` означает, что сессия не протухнет,
пока пользователь активно использует приложение. Это тоже хорошее поведение.

Теперь залогинься под любым пользователем и найди в меню приложения ссылку на страницу Decode и перейди по ней.
На этой странице аутентификационная кука расшифровывается, а затем информация из нее выводится.
Ниже на странице выводится информация о пользователе из поля `User` контроллера, т.е. как ее видят контроллеры.
Видно, что сейчас в cookie и в `User` хранится одна и та же информация.


Посмотри `/Views/Shared/_IdentityDecodePartial.cshtml`, чтобы понять, как можно достать данные о пользователе
из cookie и из `User`. Запоминать тонкости реализации не нужно.

Стоит убедиться, что данные в cookie защищаются с помощью `IDataProtector`, реализацию которого можно задать.
В частности, чтобы cookie зашифровывались по некоторому алгоритму с известным серверу ключом при создании
и расшифровывались при использовании.

Также стоит разобраться с используемыми понятиями:

- Обрати внимание, что «пользователь» (`User`) может включать в себя несколько «личностей» (`Identities`).
Это нужно, потому что информация о пользователе может приходить из разных источников (cookie, headers и т.д.)
и может быть разной. В одном случае — это Вики, в другом — Скарлетт Йоханссон. И все личности — это один пользователь.
- Также обрати внимание, что при расшифровке cookie из нее достается `AuthenticationTicket`, т.е. «удостоверение».
«Удостоверение» хранит разную информацию и в частности свойство `Principal`.
«Приципал» — это лицо, от чьего имени может действовать предъявитель удостоверения.
В данном случае браузер, который отправил нашему сервису cookie.
- Наконец, еще одно понятие — claims. Это некоторые «утверждения» про «личность», представляющие из себя
пары ключ-значение. Например, «возраст = 72», «роль = режиссер», «гражданство = США».
На основании этих «утверждений» пользователю могут быть доступны те или иные действия в приложении.


Если надо хранить в сессии много данных о пользователе, то аутентификационная кука станет достаточно большой.
Неэкономично заставлять браузер передавать все эти данные с каждым запросом в виде cookie.
В этом случае можно хранить данные о сессии на сервере.

Для хранения сессии на сервере хорошо подойдет распределенной InMemory хранилище.
InMemory — для скорости, распределенное — для отказоустойчивости. Например, подойдет Redis.
Но для учебных целей воспользуемся все тем же Sqlite.

Готовые хранилища уже реализованы в `Services/EntityTicketStore.cs` и `Services/MemoryCacheTicketStore.cs`
Посмотри как они устроены.

`MemoryCacheTicketStore` проще, потому что хранит всю информацию о сессиях в оперативной памяти.
Это очень быстро, но перезагрузка веб-сервера заставит пользователей входить заново. Не надо так.

Поэтому подключать стоит `EntityTicketStore`, сделай это:
```cs
services.AddTransient<EntityTicketStore>();
services.ConfigureApplicationCookie(options =>
{
    var serviceProvider = services.BuildServiceProvider();
    options.SessionStore = serviceProvider.GetRequiredService<EntityTicketStore>();
    /* добавленный ранее код конфигурации */
});
```

Так как это хранилище использует Entity Framework Core, надо его сконфигурировать,
а затем выполнить миграцию и обновление базы данных:

1. Сконфигурируй `TicketsDbContext` в `IdentityHostingStartup.cs` аналогично `UsersDbContext`
2. Добавь значение для `TicketsDbContextConnection` в `appsettings.json`,
причем можешь снова использовать `PhotosApp.db` в качестве файла БД
3. `dotnet ef migrations add Tickets --context TicketsDbContext`
4. `dotnet ef database update --context TicketsDbContext`,
либо добавить `dbContext.Database.Migrate()` в `Data/DataExtensions.cs`
5. Вызови метод `SeedWithSampleTicketsAsync` в `Data/DataExtensions.cs`, передав туда `TicketsDbContext`,
чтобы зачищать все сессии перед стартом приложения. Пользователи каждый раз пересоздаются — значит
нет смысла хранить сессии.

После подключения снова залогинься и перейди на страницу Decode.
Обрати внимание, что теперь в аутентификационной куке хранится только идентификатор сессии.
Вся остальная информация о пользователе хранится и незаметно достается из Sqlite.


## 3. Роли и политики

### 3.1. Роли

Не весь функционал должен быть доступен каждому пользователю.
Требуется ограничить права различных групп пользователей.


Один из способов — ввести систему ролей.
Добавь новую роль `Dev`, присвой ее уже имеющемуся пользователю `dev@gmail.com` и сделай так,
чтобы только пользователи с ролью `Dev` имели доступ к `DevController`.

Подсказки:

- В конфигурировании `Identity` в `IdentityHostingStartup.cs` надо добавить `.AddRoles<IdentityRole>()`
сразу после `.AddDefaultIdentity<PhotoAppUser>()`
- Нужно создать Роль в БД. Код создания роли уже есть в методе `SeedWithSampleRolesAsync`.
Сделай так, чтобы метод `SeedWithSampleRolesAsync` из `DataExtensions.cs` выполнялся при создании БД,
т.е. в методе `PrepareDB`, причем до `SeedWithSampleUsersAsync`.
Тебе понадобится `RoleManager<IdentityRole>`: достань его из `ServiceProvider`.
- Добавить пользователю новую роль можно командой `await userManager.AddToRoleAsync(user, "RoleName")`
- Защитить метод или контроллер можно с помощью атрибута с параметром: `[Authorize(Roles = "RoleName")]`

Когда закончишь, убедись, что только пользователь `dev@gmail.com` может пользоваться страницей Decode,
а у других пользователей возникает сообщение об ошибке.


Будет хорошо, если пользователи, которым недоступен Decode вообще не будут видеть ссылку на страницу. Сделай так!
Проверить во view, что у текущего пользователя есть роль можно так: `User.IsInRole("RoleName")`


### 3.2. Политики

Более гибко настраивать права пользователей позволяют политики на основании различных claims (утверждений) пользователя.

Сейчас любому пользователю при заходе на страницу отдельной фотографии доступно изменение подписи к фотографии.
Сделай так, чтобы возможность редактировать подписи к фотографиям была доступна только beta-тестерам.

Для начала в `IdentityHostingStartup.cs` нужно зарегистрировать некоторую политику:
```cs
services.AddAuthorization(options =>
{
    options.AddPolicy(
        "Beta",
        policyBuilder =>
        {
            policyBuilder.RequireAuthenticatedUser();
            policyBuilder.RequireClaim("testing", "beta");
        });
});
```

Эта политика требует, чтобы пользователь был аутентифицирован и у него был claim `testing` со значением `beta`.
Сейчас таких пользователей нет.

Сделай так, чтобы при старте приложения пользователю `vicky` добавлялся такой claim.
Подсказка: `await userManager.AddClaimAsync(user, new Claim("claimType", "claimValue"))`
Claim, добавленные таким образом хранятся в отдельной таблице.
Можешь в этом убедиться с помощью https://sqliteonline.com/.

Теперь защити действие `EditPhoto` в `PhotoController` с помощью атрибута `[Authorize(Policy = "Beta")]`.


Когда закончишь, убедись, что только пользователь `vicky@gmail.com` может редактировать подписи к фотографиям,
а у других пользователей возникает сообщение об ошибке.


Будет хорошо, если пользовали, которым недоступно редактирование подписей вообще не видели ссылки на это действие.
Проверить во view выполнение политики для пользователя можно так:
```cshtml
(await AuthorizationService.AuthorizeAsync(User, "PolicyName")).Succeeded
```
Только надо добавить в начале view подключение зависимостей:
```cshtml
@using Microsoft.AspNetCore.Authorization
@inject IAuthorizationService AuthorizationService
```
Скрой действие «Изменить подпись» на странице отдельной фотографии.


Когда закончишь с этим добавь еще одну политику: пусть только платым пользователям будет доступна загрузка фотографий.
Назови политику `CanAddPhoto`, в качестве типа claim используй `subscription`, в качестве значения `paid`.
Аналогично предыдущей политике, защити методы `PhotoController` для загрузки фотографий.
и скрой ссылку «Добавить фото» в меню приложения. Также скрой ссылку на метод `AddPhoto` в `Index.cshtml`,
которая показывается, когда у пользователя нет фотографий.

А вот claim в пользователя надо выставить иначе. Путь он не хранится отдельно в таблице, а вычисляется по свойствам из `PhotoAppUser`.

Для этого:

1. Добавь в класс `PhotoAppUser` булево свойство `Paid`.
2. Создай миграцию, т.к. надо добавить новую колонку в таблицу пользователей:
`dotnet ef migrations add Paid --context UsersDbContext`
2. Разбери generic-параметр `TUser` в методе `SeedWithSampleUsersAsync`, заменив его использования
на тип `PhotoAppUser`.
3. Сделай так, чтобы пользователю `cristina` при создании в свойство `Paid` выставлялось значение `true`. 
4. Самое важное! Допиши класс `CustomClaimsPrincipalFactory`
в файле `Services/Authorization/CustomClaimsPrincipalFactory.cs`.
Сначала замени во всем файле использование `IdentityUser` на `PhotoAppUser`, 
а затем сделай так, чтобы пользователю с `Paid == true` выставлялся claim `subscription` со значением `paid`.
5. Зарегистрируй фабрику в `IdentityHostingStartup.cs` в конфигурации `Identity`,
добавив для этого вызов `.AddClaimsPrincipalFactory<CustomClaimsPrincipalFactory>()`
в цепочку вызовов после `.AddDefaultIdentity<PhotoAppUser>()`.

Убедись, что пользователю `cristina` доступно добавление фото, `vicky` не доступно.

Как видишь, определив собственную `UserClaimsPrincipalFactory`,
можно выставить пользователю нужные claims по произвольным правилам «на лету»,
т.е. без хранения самих claims в базе данных.


### 3.3. Обработчик для требования

В приложении до сих пор любой аутентифицировавшийся пользователь может открыть любую фотографию,
если у него будет прямая ссылка до нее.

Убедись в этом:

1. Зайди под пользователем `vicky`
2. Перейди на страницу с одной фотографией и сохрани URL страницы
3. Выполни logout и зайди под пользователем `cristina`
4. Используй сохраненный URL, чтобы открыть фотографию. Она доступна другому пользователю!

Чтобы создать политику, которая бы запрещала доступ к фото другим пользователям,
потребуется `AuthorizationHandler`.


Для начала создай новую политику `MustOwnPhoto`, а в ней потребуй два условия:
```cs
policyBuilder.RequireAuthenticatedUser();
policyBuilder.AddRequirements(new MustOwnPhotoRequirement());
```

`MustOwnPhotoRequirement` — некоторое требование, которое будет проверяться динамически с помощью обработчика.
Обработчик для этого требования уже добавлен. Это класс `MustOwnPhotoHandler`. Он может быть
обработчиком требования, потому что наследуется от класса `AuthorizationHandler<MustOwnPhotoRequirement>`.

Но, чтобы обработчик создавался его надо зарегистрировать в качестве `IAuthorizationHandler`:
```cs
services.AddScoped<IAuthorizationHandler, MustOwnPhotoHandler>();
```

Защити действия `GetPhoto`, `GetPhotoFile`, `EditPhoto`, `DeletePhoto` в `PhotoController` с помощью новой политики.
Заметь, что это нормально использовать несколько атрибутов `Authorize` у метода.
В этом случае для выполнения действия должны быть выполнены требования каждого атрибута.

Допиши `MustOwnPhotoHandler` так, чтобы требование выполнялось,
если текущий пользователь является владельцем фотографии.


## 4. Аутентификация через Google

ASP.NET Core включает встроенную поддержку для OAuth, за счет чего к нему
легко подключить внешних провайдеров аутентификации.
А для некоторых, включай Google и Facebook есть даже готовые методы,
позволяющие подключить провайдера, написав пару строчек.

Добавь следующий код в `IdentityHostingStartup.cs`:
```cs
services.AddAuthentication()
    .AddGoogle("Google", options =>
        {
            options.ClientId = context.Configuration["Authentication:Google:ClientId"];
            options.ClientSecret = context.Configuration["Authentication:Google:ClientSecret"];
        });
```
Это почти все, что нужно, чтобы заработала аутентификация через Google в случае `Identity`,
потому что отображение нужных кнопок для внешних провайдеров аутентификации уже реализовано.


Осталось только зарегистрировать приложение в Google, получить Client ID и Client Secret,
а затем положить их в настройки, чтобы следующие строчки работали корректно:
```cs
options.ClientId = configuration["Authentication:Google:ClientId"];
options.ClientSecret = configuration["Authentication:Google:ClientSecret"];
```

Для этого:

1. Перейди на страницу https://developers.google.com/identity/sign-in/web/sign-in#before_you_begin
2. Нажми кнопку «Configure Project»
3. Введи имя нового проекта
4. Выбери опцию Web server и введи https://localhost:7001/signin-google в качестве «Authorized redirect URIs».
5. Нажми на кнопку «Create», а затем получи Client ID и Client Secret

`/signin-google` — это путь, по которому Google отправит данные пользователя
после успешной аутентификации. Такой адрес используется по умолчанию в ASP.NET Core, соответственно,
данные от Google будут успешно получены и обработаны Authentication Middleware.


Client ID и Client Secret используются авторизации приложения в Google.
Их можно сохранить в `appsettings.json`, по ключам `Authentication:Google:ClientId`
и `Authentication:Google:ClientSecret` и все будет работать.
Но файлы, хранящиеся в репозитории, в том числе `appsettings.json` — это плохое место для хранения паролей и секретов.

Поэтому лучше воспользоваться специальным хранилищем для секретов вот так:
```
dotnet user-secrets set "Authentication:Google:ClientId" "<client id>"
dotnet user-secrets set "Authentication:Google:ClientSecret" "<client secret>"
```

В этом случае значения будут сохранены тут:
- `%APPDATA%\Microsoft\UserSecrets\<user_secrets_id>\secrets.json` в Windows
- `~/.microsoft/usersecrets/<user_secrets_id>/secrets.json` в Linux, Mac

В Visual Studio секретами можно управлять, если кликнуть правой кнопкой мыши по проекту в «Solution Explorer»
и выбрать пункт «Manage Secrets».

После сохранения реквизитов в хранилище для секретов не обязательно их удалять из `appsettings.json`,
потому что значения из хранилища более приоритетны и перетрут значения из `appsettings.json`.


Далее своими проектами в Google можно будет управлять через специальный «пульт»:
https://console.developers.google.com/apis/credentials


После верного задания Client ID и Client Secret аутентификация через Google
должна появиться на странице логина и корректно работать.


## 5. Письма

Хорошая практика — предлагать пользователю подтвердить адрес своей электронной почты,
чтобы случайная опечатка при вводе email или забытый пароль не приводили к потере доступа к аккаунту.

`Identity` пытается отправлять письма с кодом подтверждения всем новым пользователям с помощью `IEmailSender`.
По умолчанию он реализован так, что ничего не отправляет.


В `Services/SimpleEmailSender` есть реализация, которая умеет отправлять письма через внешний SMTP-сервер.
Подключи ее:
```cs
services.AddTransient<IEmailSender, SimpleEmailSender>(serviceProvider =>
    new SimpleEmailSender(
        serviceProvider.GetRequiredService<ILogger<SimpleEmailSender>>(),
        serviceProvider.GetRequiredService<IWebHostEnvironment>(),
        context.Configuration["SimpleEmailSender:Host"],
        context.Configuration.GetValue<int>("SimpleEmailSender:Port"),
        context.Configuration.GetValue<bool>("SimpleEmailSender:EnableSSL"),
        context.Configuration["SimpleEmailSender:UserName"],
        context.Configuration["SimpleEmailSender:Password"]
    ));
```
Большинство настроек для подключения к SMTP-серверу Google уже прописаны в `appsettings.json`.
Пропиши в файл или в User Secrets адрес своей электронной почты Google в `UserName`
и соответствуйщий пароль в `Password`.

Также, чтобы «стороннее приложение», которое ты пишешь, смогло отправлять письма придется
понизить уровень безопасности аккаунта на странице https://myaccount.google.com/lesssecureapps

Зарегистрируй нового пользователя с существующим email и убедись, что на него пришло письмо
для подтверждения адреса электронной почты.


Если нужно, чтобы без подтверждения email нельзя было войти в аккаунт,
следует изменить настройку `SignIn.RequireConfirmedEmail` для `Identity`.
Но в обучающем проекте нам это не нужно.


Хоть подтвреждение почты является важной частью регистрации, в дальнейших заданиях она не понадобится.
Поэтому можно вернуть обратна настройки безопасности аккаунта Google: https://myaccount.google.com/lesssecureapps
А для настроек `UserName` и `Password` задай пустые строки в качестве значений.


## 6. Json Web Token и схемы аутентификации

Сейчас тебе предстоит добавить нестандартный способ аутентификации в сервисе.
Работать он должен так: пользователь переходит по секретному URL, где ему выставляется cookie с JWT-токеном.
Этот короткоживущий токен дает доступ разработчика к сервису на полминуты.


Найди и открой `HackController`. В методе `GenerateToken` с суперсекретным адресом вызывается генерация JWT-токена.
Затем этот токен добавляется в cookie.

Для начала надо доработать генерацию токена в методе `TemporaryTokens.GenerateEncoded`.

1. Сделай так, чтобы токен не действовал до текущего момента.
Для этого надо передать текущее время в UTC в `notBefore`.
2. Сделай так, чтобы токен действовал всего лишь 30 секунд, задав правильно `expires`.
3. Заполни `claims`:
    - Утверждению `ClaimTypes.NameIdentifier` (идентификатор пользователя) задай значение `Guid.NewGuid().ToString()`
    - Утверждению `ClaimsIdentity.DefaultNameClaimType` (имя пользователя) задай какое-нибудь значение
    - Утверждению `ClaimsIdentity.DefaultRoleClaimType` (роль пользователя) задай значение `"Dev"`
4. Чтобы токен нельзя было подделать можно добавить зашифрованный с помощью симметричного ключа отпечаток.
В этом случае получатель токена, если у него есть ключ шифрования, сможет построить свои отпечаток
и сравнить с отпечатком, добавленным издателем. Если отпечатки не совпадут, значит токен поддельный.
Воспользуйся алгоритмом HMAC SHA-256.
SHA-256 — хэш-функция, HMAC — алгоритм, использующий симметричный ключ и некоторую хэш-функцию для получения отпечатка.
Все уже реализовано, надо только правильно задать `signingCredentials`.
Используй ключ из свойства `TemporaryTokens.SigningKey`, а имя алгоритма есть в константе `SecurityAlgorithms.HmacSha256`.

Теперь, если обратиться по пути `/hack/super_secret_qwe123` будет возвращен токен. Он также окажется в cookie.

Получи и расшифруй этот токен с помощью сервиса https://jwt.io/.
Передай зашифрованный вариант и убедись, что в «PAYLOAD» там заданные тобой данные.

Добейся того, чтобы появилась надпись «Signature Verified».
Алгоритм подписи должен автоматически выставиться в HS256, т.к. он передается в заголовке токена,
так что осталось передать правильный ключ симметричного шифрования в блоке «VERIFY SIGNATURE».


Итак, правильный JWT-токен уже можно получить в виде cookie.
Но пока приложение никак на это не реагирует. Надо это исправить.

Добавь следующий код в `IdentityHostingStartup.cs`:
```cs
services.AddAuthentication()
    .AddJwtBearer(options =>
    {
        options.RequireHttpsMetadata = false;
        options.TokenValidationParameters = new TokenValidationParameters
        {
        };
    });
```
После этого аутентификация по JWT-токены в какой-то степени начнет поддерживаться. Но надо донастроить.

В `TokenValidationParameters`:

1. Выстави `ValidateIssuer` и `ValidateAudience` в `false`,
потому что информация об издателе и получателях токена не добавлялась.
2. Выстави `ValidateLifetime` в `true`, чтобы старые токены не работали.
Также задай `ClockSkew = TimeSpan.Zero`. Дело в том, что токены генерируются и проверяются обычно на разных серверах
и время на них может отличаться. Поэтому при проверке токенов допускается погрешность в несколько минут.
Это правильно, но для корректной работы токена с временем жизни в полминуты нужно от погрешности отказаться.
3. Выстави `ValidateIssuerSigningKey` в `true`, чтобы проверялся отпечаток токена.
В `IssuerSigningKey` передай использованный при создании отпечатка ключ.

Еще один нюанс — откуда будет доставаться токен.
Обычно JWT-токены передаются в заголовке `Authorization` и подписью `Bearer`, которая указывает,
что авторизация будет с помощью токена «на предъявителя».
Выглядит это примерно так:
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.Et9HFtf9R3GEMA0IICOfFMVXY7kkTX1wr4qCyhIf58U
```

*Замечание. Другим распространенным способом авторизации является Basic, в которой в заголовке Authorization*
*передается подпись Basic, после чего идет строка логин:пароль (например, aladdin:opensesame),*
*закодированная с помощью base64.*
*Выглядит это примерно так:*
```
Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
```

Сейчас же токен хранится в cookie. Но можно подсказать ASP.NET Core откуда брать токен вот так:
```cs
options.Events = new JwtBearerEvents
{
    OnMessageReceived = c =>
    {
        c.Token = c.Request.Cookies["NameOfCookieWithToken"];
        return Task.CompletedTask;
    }
};
```
Только не забудь передать правильное имя cookie.


Аутентификация по JWT-токенам теперь должна работать.

Проверь, что токен правильно генерируется и преобразуется в `User`:

1. Перейди по секретному адресу `/hack/super_secret_qwe123` и получи токен.
2. Перейди на секретную страницу декодирования пользователя `/hack/decode`,
которая требует авторизацию токеном и убедись, что пользователь заполнен.


Пора настроить авторизацию. Сейчас она настроена использовать только `Identity`.
Надо сделать так, чтобы авторизация поддерживала оба способа аутентификации: `Identity` и `JwtBearer`.

Сначала немного теории. У каждого способа аутентификации есть идентификатор — схема.
`Identity` использует сразу несколько схем. Название основной схемы хранится
в константе `IdentityConstants.ApplicationScheme` и равно `"Identity.Application"`.
Также в `Identity` используется схема `"Identity.External"` для внешних провайдеров, например, Google.
Для `JwtBearer` значение схемы по умолчанию хранится в константе `JwtBearerDefaults.AuthenticationScheme`
и равно `"Bearer"`.
Если надо добавить поддержку нескольких видов `JwtBearer`, то можно задать схему явно:
```cs
services.AddAuthentication()
    .AddJwtBearer("SomeJWT", options => { /* */ })
    .AddJwtBearer("AnotherJWT", options => { /* */ });
```

`Identity` тоже добавляет свой способ аутентификации при вызове `services.AddDefaultIdentity<PhotoAppUser>()`.
В `AddDefaultIdentity` скрыт следующий код:
```cs
services.AddAuthentication(o =>
{
    o.DefaultScheme = IdentityConstants.ApplicationScheme;
    o.DefaultSignInScheme = IdentityConstants.ExternalScheme;
}).AddIdentityCookies();
```
`AddIdentityCookies` — это добавляемый способ аутентификации.
А настройка `DefaultScheme` — это та схема, которая будет использоваться по умолчанию для различных операций.
В том числе атрибутом `[Authorize]`. И `AddDefaultIdentity` выставляет `Identity` для использования по умолчанию.


`Identity` в качестве схемы по умолчанию — это нормально, пусть так и будет.
А надо сделать так, чтобы `[Authorize]` стал поддерживать новый способ аутентификации.
Для этого надо переопределить политику авторизации по умолчанию вот так:
```cs
services.AddAuthorization(options =>
{
    options.DefaultPolicy = new AuthorizationPolicyBuilder(
        JwtBearerDefaults.AuthenticationScheme,
        IdentityConstants.ApplicationScheme)
        .RequireAuthenticatedUser()
        .Build();
        /* добавленный ранее код конфигурации */
}
```
Новая политика использует и `Identity`, и `JwtBearer`.


Пришло время для проверки:

1. Перейди по секретному адресу `/hack/super_secret_qwe123` и получи токен.
2. Перейди на главную страницу и убедись, что доступна ссылка «Decode», как и всем разработчикам.
3. Перейди по ней и убедись, что сам метод пока еще не доступен.


Настройка политики по умолчанию никак не влияет на атрибуты с дополнительными настройками,
в том числе на `[Authorize(Roles = "Dev")]`, поэтому страница по ссылка «Decode» еще не работает.

Быстрый способ починить — дополнительно к роли перечислить в атрибуте допустимые схемы через запятую:
```cs
[Authorize(Roles = "Dev", AuthenticationSchemes = "Bearer, Identity.Application")]
```
Но так делать сейчас не надо.

Качественный способ решить эту проблему — везде для конфигурирования авторизации использовать политики,
как ранее использовали `[Authorize(Policy = "Beta")]`. Глядя на политику по умолчанию и другие политики,
добавь политику `"Dev"`. Тебе пригодятся методы `RequireRole` и `AddAuthenticationSchemes` у `policyBuilder`.
Для корректной работы этой политики надо добавить обе схемы: `JwtBearerDefaults.AuthenticationScheme`
и `IdentityConstants.ApplicationScheme`. Причем именно в таком порядке! Объяснения почему будет немного позже.

Как добавишь политику — используй ее! Во-первых, в `DevController`, поправив атрибут `Authorize`.
Во-вторых, при показе ссылки «Decode» в `_Layout.cshtml`, сделав аналогично показу ссылки «Добавить фото».
После этого ссылка «Decode» должна заработать.
Причем как для аутентификации по токену, так и для пользователя `dev@gmail.com`.


Итоговая проверка:

1. Перейди по секретному адресу `/hack/super_secret_qwe123` и получи токен.
2. Залогинься под пользователем `vicky@gmail.com`.
3. Перейди на главную страницу и убедись, что отображаются фотографии пользователя `vicky@gmail.com`.
4. Убедись, что в качестве имени пользователя в правом верхнем углу главной страницы отображается `vicky@gmail.com`.
5. Убедись, что доступна ссылка «Decode», как и всем разработчикам.
6. Перейди по ссылке «Decode» и убедись, что пользователь (ClaimsPrincipal) представлен
двумя личностями (ClaimsIdentity), одна из которых заполнена из токена, а другая — `vicky@gmail.com`.
7. Убедись, что в качестве имени пользователя в правом верхнем углу страницы «Decode» отображается `vicky@gmail.com`.


А теперь еще немного теории про схемы аутентификации и политики авторизации.

При аутентификации в `UseAuthentication` создается единственная `Identity` с использованием схемы по-умолчанию.
Далее создается `Principal`, который содержит эту `Identity`, и сохраняется в `User`.
При этом у `Principal` доступно свойство `Claims`, значение которого определяется `Claims`
из этой единственной `Identity`. Затем эти `Claims` используются для авторизации.

Одним предложением: по схеме по-умолчанию создается `Identity`, а затем используется при авторизации.

Но в этом случае, если какие-то claims надо взять из куки у схемы `"Identity.Application"`,
а другие из токена у схемы `"Bearer"`, авторизация работать не будет. Потому что `Identity` строится
с использованием одной схемы: схемы по-умолчанию.

Поэтому, если согласно политики для авторизации конкретного запроса требуется несколько схем,
`User`, построенный в `UseAuthentication`, переопределяется в `UseAuthorization`.
При этом для каждой схемы строится своя `Identity`, все они добавляются в `Principal`, который и сохраняется в `User`,
а затем используется для авторизации.

Но остается нюанс: а что если один и тот же claim, например, `name`, определен сразу в нескольких `Identity`?
Какое имя будет у пользователя? Ответ: claim из схемы, которая указана позже в определении политики,
будут более приоритетны.

Например, пусть в схеме `"Bearer"` у пользователя имя `Temporary Dev`, а в схеме `"Identity.Application"` — `vicky@gmail.com`.
При использовании в политике следующего кода у пользователя будет имя `vicky@gmail.com`:
```cs
policyBuilder.AddAuthenticationSchemes("Bearer", "Identity.Application")
```
А при использовании такого кода у пользователя будет имя `Temporary Dev`:
```cs
policyBuilder.AddAuthenticationSchemes("Identity.Application", "Bearer")
```

При этом не должно смущать слово `First` в коде `User.FindFirstValue(ClaimTypes.NameIdentifier)`, который можно прочесть как
«найди у пользователя первый claim с типом `nameidentifier`». Просто чем ПОЗЖЕ идет схема в определении политики,
тем РАНЬШЕ находится `Identity` этой схемы в `Principal`, т.е. в `User`.

Одним предложением: для каждой схемы из политики создается `Identity` и при авторизации используются они все,
но схемы, идущие позже, более приоритетны.


Чтобы убедиться, что это работает именно так, можно посмотреть исходники ASP.NET Core на GitHub:
- Про аутентификацию в [AuthenticationMiddleware](https://github.com/dotnet/aspnetcore/blob/master/src/Security/Authentication/Core/src/AuthenticationMiddleware.cs)
- Про авторизацию в [AuthorizationMiddleware](https://github.com/dotnet/aspnetcore/blob/master/src/Security/Authorization/Policy/src/AuthorizationMiddleware.cs)

*Замечание. Исходники на GitHub позволяют раскрыть многие нюансы работы ASP.NET Core,*
*причем, в отличие от документации или статей, говорят правду и полностью.*
*Более того, архитектура ASP.NET Core позволяет легко переопределять и расширять функциональность,*
*и, как следствие, нужные исходники можно не только посмотреть и скачать,*
*но и подключить, и отладить прямо в своем приложении. Отладка же позволяет сорвать все покровы.*
*Искать исходники достаточно удобно с помощью Google: в запросе надо написать имя класса,*
*иногда namespace, а также слово github и, возможно, asp.net core.*
*Например, "AuthenticationMiddleware asp.net core github".*
*Если же искать приходится часто, то репозиторий с ASP.NET Core можно просто склонировать:*
`git clone https://github.com/dotnet/aspnetcore`


А теперь для закрепления материала проведи несколько экспериментов:

1. Запусти приложение, аутентифицируйся под пользователем `vicky@gmail.com` и с помощью `/hack/super_secret_qwe123`,
т.е. по обеим схемам. Перейди на страницу «Decode» и проверь порядок `Identity` в `User`.
Первой должна идти `Identity` для схемы `"Identity.Application"`.

2. В политике `Dev` поменяй местами схемы, чтобы `JwtBearerDefaults.AuthenticationScheme` была последней.
То же самое сделай для `DefaultPolicy`. Запусти приложение, аутентифицируйся по обеим схемами.
Обрати внимание на имя пользователя на главной странице стало `Temporary Dev`.
Перейди на страницу «Decode» и убедись, что порядок `Identity` в `User` тоже поменялся.
Обрати внимание, что имя пользователя на странице «Dev» тоже стало `Temporary Dev`.

3. Верни исходный порядок схем в политике `DefaultPolicy`. Запусти приложение, аутентифицируйся по обеим схемами.
Обрати внимание, что ссылка «Decode» на главной странице доступна, а имя пользователя — `vicky@gmail.com`.
Перейди на страницу «Decode» и обрати внимание, что имя пользователя отличается, т.е. `Temporary Dev`.

4. А теперь закомментируй в политике `Dev` добавление разных схем, т.е. `policyBuilder.AddAuthenticationSchemes`.
Запусти приложение, аутентифицируйся по обеим схемам. Обрати внимание, что ссылка «Decode»
на главной странице доступна. Перейди по ней и убедись, что доступ к странице запрещен.

5. Раскоментируй `policyBuilder.AddAuthenticationSchemes` в политике `Dev` и убери добавление схем в `DefaultPolicy`.
Запусти приложение, аутентифицируйся по обеим схемам. Обрати внимание, что ссылка «Decode» исчезла с главной страницы.
Переди напрямую на странцу `/Dev/Decode`: она будет доступна и на ней будет ссылка «Decode».

6. Верни все, как было.

Полагаю, что с пунктами 1, 2 и 3 все понятно: на каждой странице действует некоторая политика и используется
тот порядок `Identity`, который соответствует добавлению схем в этой политике.

А вот пункт 4 не так очевиден. На первый взгляд, страница «Decode» недоступна, потому что схему
`JwtBearerDefaults.AuthenticationScheme` в политику не добавили. То, что схема `JwtBearerDefaults.AuthenticationScheme`
при этом добавлена в `DefaultPolicy` значения не имеет.
Хорошо. Но тогда почему доступна ссылка «Decode» на главной странице? Все потому, что на главной странице в `User`
находятся `Identity` для обеих схем, как это указано в `DefaultPolicy`, а значит пользователь аутентифицирован
и у него есть роль `Dev`. Ограничения политики `Dev` выполняются, пусть даже для этого использована «лишняя» схема.

Обратная ситуация в пункте 5. Было бы логично, чтобы ссылка на страницу «Decode» была доступна на главной.
Но нет. На главной странице основная политика — `DefaultPolicy`, в которой в этом пункте подключена только одна схема.
Поэтому в `User` находится только одна `Identity`, а значит у пользователя него нет роли `Dev`.

В пунктах 4 и 5 поведение немного странное. Может быть оно изменится в будущем, но пока оно такое и соответствует исходникам.

Вывод: чтобы не получать странные спецэффекты, во всех политиках стоит использовать один и тот же набор схем аутентификации.


## 7. Авторизация в другом сервисе с помощью Client Credentials Flow

До сих пор бэкенд веб-приложения работал в рамках одного веб-сервера. В реальных веб-приложениях это обычно не так.
Чаще всего есть некое веб-приложение, который отдает HTML-странички со скриптами и стилями, а большинство работы
выполняется отдельными веб-сервисами. Такие веб-сервисы обычно находятся отдельно от веб-приложения: на другой виртуалке,
на другой физической машине или даже в другом дата-центре.

*Замечание. Не вдаваясь в четкое определение понятия «веб-приложение», здесь и далее под этим термином*
*будет подразумеваться только веб-сервер, в котором выполняется программа, непосредственно взаимодействующая*
*с браузером пользователя: отдающая разметку, стили, скрипты и предоставляющие API для скриптов.*
*В нашем случае это PhotosApp.*
 
Из-за разделения на веб-приложения и веб-сервисы возникает вопрос: как защитить веб-сервисы от запросов от злоумышленников
и дать доступ своим веб-приложениям? Понятно, что в том или ином виде нужна авторизация для собственных веб-приложений.

Один из способов — использовать API-ключи. Разработчики веб-сервиса некоторым образом передают
разработчикам веб-приложения API-ключи, каждый из которых представляет собой уникальную строку.
А затем при запросах от веб-приложения к веб-сервису передается подходящий API-ключ.
Веб-сервис обнаруживает API-ключ в запросе и, если ключ еще действует, выполняет запрос.


Более продвинутый способ — использовать Client Credentials Flow протокола авторизации OAuth.

В этом случае кроме приложения и сервиса появляется еще одна сторона — сервер авторизации. Приложение регистрируется
в качестве клиента в сервере авторизации. А сервер авторизации затем выдает правильным клиентам правильные права.
Сервис тоже регистрируется в сервере авторизации, но в качестве ресурса. Сервис не получает каких-либо реквизитов,
но по сути обязуется доверять решениям сервера авторизации.

При регистрации приложению выдается client id и password. При необходимости доступа к ресурсам,
приложение предъявляет эти реквизиты серверу авторизации и запрашивает доступ к некоторому
множеству ресурсов, т.е. сервисов. Если сервер авторизации согласен, то выдает некий «токен»,
который приложение может использовать для доступа к запрошенным ресурсам.

Токен похож на API-ключ, но между двумя схемами есть отличия:

- В случае OAuth реквизиты клиента передаются только между клиентом и сервером авторизации.
Между приложением и сервисом передаются только токены.
- Токен обычно живет недолго, поэтому его потеря не так критична. API-ключи надо отзывать и получать заново.
- Сервер авторизации становится единым удобным местом настройки прав доступа между приложениями и сервисами.
Причем создать новую связь между зарегистрированным приложением и зарегистрированным сервисом легко.


Далее выделим `PhotosService` из `PhotosApp` и добавим между ними авторизацию по Client Credentials Flow.


### 7.1. Запуск отдельных сервисов

В этом задании понадобится запускать не только `PhotosApp`, но и `PhotosService`, и `IdentityServer`.

`PhotosService` — это сервис для хранения фотографий. Этот сервис реализует API, которое можно посмотреть
в `PhotosApiController`. Делать запросы к этому API из `PhotosApp` можно с помощью `RemotePhotosRepository`.
Это одна из реализаций `IPhotosRepository`, но в отличие от `LocalPhotosRepository`, который сейчас используется
в `PhotosApp`, она не достает фотографии с диска, а делает HTTP-запросы к `PhotosService`.
Сам `PhotoService` устроен максимально просто: получает HTTP-запросы и делегирует их выполнение
своему `LocalPhotosRepository`. Который, в свою очередь, хранит данные также,
как они сейчас хранятся в `PhotosApp`: информация в Sqlite, а файлы фотографий — в папк `.photos`.

`IdentityServer` — это реализация сервера авторизации, причем реализация «по-умолчанию».
Дело в том, что для .NET Core есть хорошая реализация сервера авторизации с OAuth и OpenIDConnect — `IdentityServer4`.
И, чтобы получить свой собственный сервер авторизации достаточно выполнить такие простые команды:
```
dotnet new -i IdentityServer4.Templates
dotnet new is4empty -n IdentityServer
dotnet sln add IdentityServer\IdentityServer.csproj
```
Первая команда подключает новые шаблоны для инструмента `new`, вторая создает пустой IdentityServer,
а последняя подключает ее в solution. Для получения проекта `IdentityServer` были выполнены эти 3 команды,
а также внутрь было добавлено логирование запросов с помощью middleware `UseSerilogRequestLogging`.

Это все, что было сделано, но уже получился рабочий сервер авторизации, который в перспективе можно подключить к СУБД,
добавить к нему UI и Identity, сконфигурировать так, как требуется. Хорошая архитектура с использованием
Dependecy Inversion Principle, а также открытые исходные коды позволяют легко дополнять или переопределять функционал
IdentityServer и делают его прекрасной основой для сервера авторизации на .NET Core.

Задания будут сфокусированы на использовании сервера авторизации, а не на его настройке.
Но если понадобится настроить, то можно использовать [документацию](https://identityserver4.readthedocs.io),
более полные шаблоны для `dotnet new`: `is4aspid` с ASP.NET Core Identity и `is4ef` с Entity Framework Core,
а также [исходные коды на GitHub](https://github.com/IdentityServer/IdentityServer4).


Как же все эти сервисы запускать? Один из вариантов — все в IDE. Например, все запускать под отладкой в Rider,
или в VS Code, или один какой-то сервис в Visual Studio, а другие два — в VS Code.

Но в целом достаточно будет под отладкой запускать какой-то один из сервисов, обычно `PhotosApp`,
а остальные — просто через консоль.

Команды для запуска через консоль:

- PhotosApp: `dotnet run --project PhotosApp`
- PhotosService: `dotnet run --project PhotosService`
- IdentityServer: `dotnet run --project IdentityServer`

Для Windows в корне репозитория можно найти и использовать следующие файлы: `launchPhotosApp.cmd`,
`launchPhotosService.cmd`, `launchIdentityServer.cmd`.

При любом варианте запуска у сервисов будут следующие адреса:
- PhotosApp: `https://localhost:5001`
- PhotosService: `https://localhost:6001`
- IdentityServer: `https://localhost:7001`


Произведи тестовый запуск:

1. В `PhotosApp` в `Startup.cs` замени использование локального репозитория на удаленный.
Для этого закомментируй строчку с подключением `LocalPhotosRepository` и добавь строчку
с подключением `RemotePhotosRepository`:
```cs
// services.AddScoped<IPhotosRepository, LocalPhotosRepository>();
services.AddScoped<IPhotosRepository, RemotePhotosRepository>();
```

2. Запусти любым способом `PhotosApp` и убедись, что при открытии страницы в `RemotePhotosRepository`
выбрасывается исключение.

3. Запусти любым способом `PhotosService`, обнови страницу в браузере. траница должна загрузиться,
но без фотографий. Войди под `vicky@gmail.com` и убедись, что ее фотографии подгрузились.

4. Запусти любым способом `IdentityServer` и убедись, что он запускается.


### 7.2. Client Credentials Flow

Для начала добавь аутентификацию по токену в `PhotosService`.

1. Выполни в папке с solution:
```
dotnet add PhotosService package Microsoft.AspNetCore.Authentication.JwtBearer
```

2. Добавь в метод `ConfigureServices` в `Startup.cs` в проекте `PhotosService` следующий код:
```
services.AddAuthentication("Bearer")
    .AddJwtBearer("Bearer", options =>
    {
        options.Authority = "https://localhost:7001";
        options.Audience = "photos_service";
    });
```
В нем добавляется аутентификация по токену, причем будут приниматься только токены, которые изданы и подписаны
сервером авторизации https://localhost:7001. А еще в этих токенах должно быть указано, что они дают доступ
к ресурсу `"photos_service"`. `PhotosService` как раз и будет этим «ресурсом».

3. Добавь middleware для аутентификации и авторизации между `UseRouting` и `UseEndpoints`:
```cs
app.UseAuthentication();
app.UseAuthorization();
```

Теперь запусти `PhotosApp` и `PhotosService`, зайди в приложение под `vicky@gmail.com` и убедись,
что фотографии не загружаются, а вместо них надпись «Ничего не найдено».
Да, `RemoteRepository` написан так, чтобы не падать, если доступ к фотографиям запрещен.


Далее надо зарегистрировать новый тип ресурсов в сервере авторизации.

Сейчас все ресурсы, доступ к которым можно получить через `IdentityServer`, перечислены в файле `Config.cs`.
То, что используется именно это файл, сконфигурировано в `Startup.cs` в `IdentityServer`.

Итак, в файле `Config.cs` найди статическое свойство `Apis` и добавь туда запись о новом ресурсе:
```cs
new ApiResource("photos_service", "Сервис фотографий")
```
Запись, которая там была в качестве примера, можно удалить.


Далее надо настроить, каким приложениям будет выдаваться доступ к новому ресурсу.

В файле `Config.cs` найди статическое свойство `Clients` и добавь туда запись о новом клиенте:
```cs
new Client
{
    ClientId = "Photos App by OAuth",
    ClientSecrets =
    {
        new Secret("secret".Sha256())
    },

    AllowedGrantTypes = GrantTypes.ClientCredentials,
    AllowedScopes = { "photos_service" }
}
```
Запись, которая там была в качестве примера, можно удалить.

В добавленной записи задается идентификатор и секрет клиента, используя которые приложение `PhotosApp` будет обращаться
к серверу авторизации, описано, что общение между приложением и сервером будет по Client Credential Flow,
а также описано, что при желании приложение сможет получить токен с доступом к ресурсу `"photos_service"`.


Теперь осталось только сконфигурировать приложение `PhotosApp`.

1. Выполни в папке с solution:
```
dotnet add PhotosApp package IdentityModel
```
`IdentityModel` позволяет делать различные запросы по протоколам OAuth и OpenID Connect.

2. Используя эту болванку, добавь метод `GetAccessTokenByClientCredentialsAsync` в `RemotePhotosRepository`,
который должен получать токен для `PhotosService` от `IdentityServer`:
```cs
private static async Task<string> GetAccessTokenByClientCredentialsAsync()
{
    var httpClient = new HttpClient();
    // NOTE: Получение информации о сервере авторизации, в частности, адреса token endpoint.
    var disco = await httpClient.GetDiscoveryDocumentAsync("TODO: адрес сервера авторизации");
    if (disco.IsError)
        throw new Exception(disco.Error);

    // NOTE: Получение access token по реквизитам клиента
    var tokenResponse = await httpClient.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest
    {
        Address = disco.TokenEndpoint,
        ClientId = "TODO",
        ClientSecret = "TODO",
        Scope = "TODO: необходимые ресурсы через пробел"
    });

    if (tokenResponse.IsError)
        throw new Exception(disco.Error);

    return tokenResponse.AccessToken;
}
```

3. В методе `SendAsync` в `RemotePhotosRepository`, который отправляет все запросы к `PhotosService`,
добавь получение access token с помощью метода `GetAccessTokenByClientCredentialsAsync`.
Полученный access token надо добавить в `httpClient`, чтобы все запросы отправлялись с токеном
в заголовке `Authorization` вот так:
```cs
httpClient.SetBearerToken(accessToken);
```


Теперь на каждый запрос к `PhotosService` приложение `PhotosApp` будет получать access token от `IdentityServer`
и отправлять его в запросе. А `PhotosService` будет проверять полученный access token и предоставлять доступ,
т.к. доверяет токенам от `IdentityServer`.

Убедись, что фотографии `vicky` снова отображаются после входа в `PhotosApp`.


### 7.3 Проверка токена

Как же `PhotosService` проверяет, что пришедшим ему токенам можно доверять?
Просто. Он идет по адресу из `options.Authority`, в нашем случае это https://localhost:7001, получает открытый ключ
и проверяет подпись токена. Кроме этого он проверяет, что время действия токена не прошло и что `options.Audience`,
в нашем случае `"photos_service"`, есть среди scope токена.

Проверь токен вручную!

Для этого поставь точку останова сразу после получения access token в методе `SendAsync`, запусти `PhotosApp`
под отладкой и получи содержимое токена. Это содержимое вставь в качестве токена в сервис https://jwt.io/.
Токен будет расшифрован и можно будет убедиться, что в нем есть значение `"photos_service"` в массиве `scope`,
а также, что токен выдан на 1 час (сравни значения в `exp` и `nbf`).

Осталось проверить подпись:

1. Перейди по адресу https://localhost:7001/.well-known/openid-configuration и увидишь подробную информацию
о сервере авторизации. Именно эта информация получается в запросе `GetDiscoveryDocumentAsync`.
Там есть адреса разных endpoints, но сейчас интересен адрес `jwks_uri` — перейди по нему.

2. JWK — это Json Web Key. И по адресу из `jwks_uri` ты увидишь массив публичных ключей сервера авторизации в формате JSON.
В нашем случае он будет включать только один ключ. У ключа будут
`kid`, т.е. key identifier — это идентификатор ключа. Этот идентификатор также есть в header токена,
чтобы было понятно с каким ключом проверять подпись.
`alg` — это алгоритм шифрования, с которым можно использовать этот ключ. Этот алгоритм тоже указывается в header токена.
`e` и `n` — это числа, образующие открытый ключ в [RSA](https://ru.wikipedia.org/wiki/RSA).
Открой исходный код страницы, чтобы плагины в твоем браузере не мешали, и скопируй ключ в буфер обмена.
Полностью весь объект, а не только `e` и `n`!

3. Вставь скопированный JWK в поле для public key в сервисе https://jwt.io/.
После этого должна появиться надпись «Signature Verified».

Ура, токен проверен!
